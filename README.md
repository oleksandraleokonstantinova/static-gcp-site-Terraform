# My GCP Static Site
Фінальний проект EPAM Cloud & DevOps Fundamentals  
        Мною було успішно налаштовано автоматичне розгортання статичного сайту на Nginx до Google Cloud Run за допомогою GitHub Actions.
        
         Cпочатку проект створювався наступним чином (відповідно до вимог проекту):
Я розгорнула сайт у Google Cloud Storage та підключила його до HTTP Load Balancer, повністю керуючи створенням і оновленням файлів через GitHub-репозиторій. У репозиторії я налаштувала workflow для автоматичного деплою в GCS, виконувала коміти через Cloud Shell Editor, і GitHub Actions коректно оновлював сайт при кожній зміні. 
<img width="744" height="320" alt="image" src="https://github.com/user-attachments/assets/d8528a62-6cb2-4115-81f0-fd779185a7c4" />

       Але змінила фокус, для забеспечення автоматичного, безпечного та надійного процесу доставки статичного сайту від коду до кінцевого користувача, через надання  HTTPS (TLS).
CI/CD та HTTPS
     1.  Налаштувала HTTPS
Налаштування HTTPS автоматично завдяки використанню Google Cloud Run.
Cloud Run бере на себе управління SSL/TLS-сертифікатами. Я не керувала сертифікатами самостійно.
Я налаштувала мій Nginx у Dockerfile слухати порт 8080 (це вимога Cloud Run). Cloud Run приймає зовнішній зашифрований трафік (HTTPS) і перенаправляє його на внутрішній порт 8080 контейнера.
      2.   Алгоритм  Дій
Ось що я зробила для досягнення автоматизації:
А. Налаштування Середовища (GitHub Actions + GCP)
1.	Створила Сервісний Обліковий Запис (gha-deployer@...) на GCP для виконання команд.
2.	Налаштувала Workload Identity Federation (WIF), щоб GitHub Actions міг безпечно отримувати токен GCP для автентифікації без ключів.
3.	Створила файл Dockerfile з багатостадійною збіркою Nginx для обслуговування статичного контенту на порту 8080.
4.	Змінила файл deploy.yml для GitHub Actions, який би 
Б. Вирішення Проблем з Дозволами (IAM)
Я надавала дозволи, які були потрібні моєму SA (gha-deployer@...) для виконання кожного кроку:
•	Для завантаження коду в GCS:  додала роль Storage Object Admin (roles/storage.objectAdmin).
•	Для запуску Cloud Build:  додала роль Service Account User (roles/iam.serviceAccountUser).
•	Для розгортання в Cloud Run:  додала ролі Cloud Run Admin (roles/run.admin) та Artifact Registry Reader (roles/artifactregistry.reader).
В. Корекція Коду:  виправила помилку шляху копіювання в Dockerfile (змінила шлях /usr/share/nginx/nginx.conf на /etc/nginx/nginx.conf у фінальному етапі багатостадійної збірки).
        Чому Cloud Run Був Оптимальним:
Я обрала Cloud Run, тому що він був найкращою альтернативою для конкретного завдання, безкоштовний і простий варіант:
1.	Serverless HTTPS: Я отримала автоматичний SSL та відсутність необхідності керувати серверами (як у Firebase).
2.	Гнучкість Контейнера: Я зберегла можливість використовувати Docker та мій Nginx (на відміну від Firebase).
3.	Економічність: Я уникла високої ціни Load Balancer, оскільки Cloud Run масштабується до нуля і є дуже вигідним для статичного контенту. І відсутність власного Домен та уникла його купівлі (Придбати домен → додати A-запис на глобальний IP  LB)
    
Чому Docker-контейнеризація була оптимальним вибором для цього проєкту CI/CD:
1.	Docker забезпечив однорідність середовища, гарантуючи, що мій статичний сайт, зібраний у Cloud Build, функціонуватиме ідентично у середовищі виконання Cloud Run, що усунуло типові проблеми несумісності.
2.	Контейнеризація дозволила мені точно налаштувати вебсервер Nginx для обслуговування файлів та обов'язкового прослуховування порту 8080, що було критично необхідною вимогою для розгортання на Serverless-платформі Cloud Run.
3.	Використання Docker зробило можливим Serverless-розгортання, оскільки Cloud Run є платформою для контейнерів, забезпечуючи мені автоматичний HTTPS, масштабування до нуля та мінімальне адміністрування інфраструктури.

       І нарешті чому використання Terraform у цьому проєкті я бачу недоцільним.
Іноді в технологіях ми стикаємось із ситуацією, коли інструмент сам по собі чудовий, але абсолютно недоцільний у конкретному контексті. Цей проєкт — саме такий випадок.
Terraform — потужний інженерний бульдозер, створений для керування великими інфраструктурами, де сотні сервісів, середовищ, правил доступу та мережевих компонентів.
Але коли в тебе є один невеличкий Cloud Run сервіс, який чудово запускається за допомогою GitHub Actions, то витягувати Terraform — це як: замість тостера, щоб підсмажити хліб, використовувати промислову конвеєрну піч (60-ти метрову). 
І тут, я вважаю, проявляється ключова риса майбутнього DevOps-професіонала:
У DevOps недостатньо просто знати великий список інструментів.
Професіоналізм — це не «я знаю Terraform, Kubernetes, Helm, ArgoCD…».
Професіоналізм — це вміння вибрати саме той набір інструментів,
який максимально оптимально вирішує конкретну задачу. DevOps — це про ефективність, а не про використання всього одразу.
Terraform не додає цінності в цьому сценарії. Маємо лише один сервіс. Управління ним через Terraform не спрощує роботу, а навпаки — ускладнює. А DevOps, навпаки, прагне зменшити кількість «рухомих частин», якщо вони нічого не додають.
     Тому в цьому проєкті я свідомо обрала не Terraform, а простіший і раціональніший шлях — GitHub Actions + Cloud Build + Cloud Run. Це рішення дозволило мені створити ефективний CI/CD-пайплайн, який забезпечує безпечний (HTTPS), автоматичний та економічний деплой.
  	
Мій link: https://static-site-https-968028312951.us-central1.run.app/

    <img width="676" height="232" alt="image" src="https://github.com/user-attachments/assets/78c8c89a-4ce2-4a21-9546-26304236130a" />

<img width="975" height="467" alt="image" src="https://github.com/user-attachments/assets/51a6749f-495f-45f0-a127-83028791384a" />

<img width="735" height="253" alt="image" src="https://github.com/user-attachments/assets/c72fbaf4-df84-4448-8ac0-4276c3bdfd7e" />


