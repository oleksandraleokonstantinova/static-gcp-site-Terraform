# My GCP Static Site with Terraform
Фінальний проект EPAM Cloud & DevOps Fundamentals  
        У даному пректі мною було налаштовано повний цикл автоматизованого деплойменту сервісу на Google Cloud, використовуючи Terraform і GitHub Actions.
1. Підготовка репозиторію та очищення структури
Я створила окремий репозиторій для інфраструктури, видалила зайві файли Terraform, додала .gitignore та повністю очистила історію, щоб уникнути помилок із великими файлами. Це дало змогу підтримувати репозиторій чистим і готовим до CI/CD.
2. Створення Terraform-конфігурації
У каталозі infra/ я описала:
ресурс Cloud Run;
публічний доступ через IAM;
змінні для проєкту, регіону, сервісу та Docker-образу.
Terraform дозволив мені формалізувати інфраструктуру в коді та робити її передбачуваною.
3. Налаштування GitHub Actions
Я створила workflow, який:
аутентифікується в Google Cloud через Workload Identity Federation,
будує Docker-образ у Cloud Build,
запускає terraform init та terraform apply.
У результаті весь процес розгортання став автоматизованим та повторюваним.
4. Workload Identity Federation
Я створила Workload Identity Pool та OIDC-провайдер, додала атрибутні мапінги й обмежила доступ тільки до мого GitHub-репозиторію.
Далі надала сервісному акаунту роль Workload Identity User, що дозволило GitHub Actions працювати взагалі без ключів.
5. Робота зі секретами
Я додала секрети GCP_PROJECT_ID, GCP_REGION, GCP_SERVICE_NAME, GCP_SERVICE_ACCOUNT_EMAIL, GCP_WORKLOAD_IDENTITY_PROVIDER.
Вони використовуються у пайплайні для деплойменту.
6. Вирішення помилок
У процесі я виправила такі типові помилки:
неправильний audience для WIF,
недостатні IAM-права,
спроба створити сервіс, який уже існував (409 Conflict),
помилки доступу до токенів.
Після усунення цих проблем пайплайн запрацював стабільно.
Terraform State
У процесі налаштування інфраструктури я винесла Terraform state у окремий backend, щоб забезпечити стабільну та передбачувану роботу Terraform. Спочатку state зберігався локально у Cloud Shell, через що виникали конфлікти: Terraform не бачив раніше створених ресурсів і намагався створювати їх повторно. Це ускладнювало роботу, особливо коли інфраструктура оновлювалась як вручну, так і через GitHub Actions.
Щоб вирішити проблему, я створила окремий приватний GCS-bucket і зберегла Terraform state саме там. Завдяки цьому Terraform тепер використовує один спільний файл стану незалежно від того, звідки запускається — локально чи з CI. Це дозволяє коректно відслідковувати зміни, уникати дублювання ресурсів і працювати з інфраструктурою як з єдиним цілісним середовищем.
З точки зору безпеки, bucket із state доступний лише через IAM і повністю закритий для публіки, тому файл не потрапляє у GitHub та не піддається ризикам. У подальшій роботі цей state буде автоматично оновлюватися Terraform при кожному apply, слугуючи єдиним джерелом правди для всієї інфраструктури.

Висновки
Переваги:
інфраструктура тепер повністю описана в коді;
деплой автоматизований і не потребує ручних дій;
конфігурація легко масштабуються;
безключова аутентифікація через WIF — сучасна та безпечна.
Недоліки:
для маленького проєкту Terraform і WIF є занадто складними;
початкове налаштування потребує багато часу;
підтримка такої системи складніша, ніж простий ручний деплой.
Фінальний результат
Мені вдалося створити повністю автоматизований процес розгортання сервісу, заснований на сучасних хмарних практиках.
Цей підхід є надмірним для простого сайту, але надає цінний досвід роботи з Terraform, IAM та CI/CD, який я зможу застосовувати в реальних комерційних проєктах.

link site: https://static-site-tf-968028312951.us-central1.run.app/

<img width="1609" height="642" alt="image" src="https://github.com/user-attachments/assets/0620cafe-cf07-4f57-85e7-f058db8f275c" />


<img width="1856" height="853" alt="image" src="https://github.com/user-attachments/assets/8a52afc7-3038-45d0-8dce-6eda966b37d5" />


<img width="1643" height="447" alt="image" src="https://github.com/user-attachments/assets/7f18c6af-32cc-497c-b8f0-30546b85d37f" />



        
        

